- Check if Kubernetes is running and nodes are ready.
kubectl cluster-info
kubectl get node
    
kubectl api-resources
   

- To view kubectl commands:
   
kubectl help
   

- Get the documentation of `Nodes` and its fields.
  
kubectl explain nodes
   

- View the nodes in the cluster using.
  
kubectl get nodes
   

- Get the documentation of `Pods` and its fields.
  
kubectl explain pods
   

# Hangi version olmasi gerektigine bakabiliyoruz
kubectl api-resources      

- Create a pod with `kubectl create` command.
  
kubectl create -f mypod.yaml
   

- List the pods.
  
kubectl get pods
   

- List pods in `ps output format` with more information (such as node name). 
  
kubectl get pods -o wide
   

- Show details of pod.
  
kubectl describe pods/nginx-pod
   

- Show details of pod in `yaml format`.  
  
kubectl get pods/nginx-pod -o yaml
   

- Delete the pod.

kubectl delete -f mypod.yaml
# or
kubectl delete pod nginx-pod
   

- Get the documentation of `replicasets` and its fields.
    
kubectl explain replicaset
   

- Create yaml file named `myreplicaset.yaml` and explain fields of it.

   yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-rs
  labels:
    environment: dev
spec:
  # modify replicas according to your case
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: mynginx
        image: nginx
        ports:
        - containerPort: 80
   

- Create the replicaset with `kubectl apply` command.

    
kubectl apply -f myreplicaset.yaml
   

- List the replicasets.

    
kubectl get replicaset
   

- List pods with more information.
  
    
kubectl get pods -o wide
   

- Show details of replicasets.

    
kubectl describe replicaset <replicaset-name>
   

- Delete replicasets

    
kubectl delete replicaset <replicaset-name>
   

#### Pod Selector

The .spec.selector field is a label selector. 

The .spec.selector field and .spec.template.metadata field must be same. There are additional issues related this subject like louse coupling, but we discuss this on service object.  

### Deployments

- Get the documentation of `Deployments` and its fields.

    
kubectl explain deployments
   

- Create yaml file named `mydeployment.yaml` and explain fields of it.

   yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    environment: dev
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
   

- Create the deployment with `kubectl apply` command.
  
    
kubectl apply -f mydeployment.yaml
   

- List the deployments.

    
kubectl get deployments
   

- List pods with more information.
  
    
kubectl get pods -o wide
   

- Show details of deployments.

    
kubectl describe deploy/nginx-deployment
   

- Print the logs for a container in a pod.

    
kubectl logs <pod-name>
   

- If there is a multi-container pod, we can print logs of one container.

    
kubectl logs <pod-name> -c <container-name>
   

- Execute a command in a container.

  
kubectl exec <pod-name> -- date
   

  
kubectl exec <pod-name> -- cat /usr/share/nginx/html/index.html
   

- Open a bash shell in a container.

  
kubectl exec -it <pod-name> -- bash
   

- List the ReplicaSets.

  
kubectl get rs
   

- Show details of ReplicaSets.

  
kubectl describe rs <rs-name>
   

- Scale the deployment up to five replicas.

  
kubectl scale deploy nginx-deployment --replicas=5
   

- But each time do we have to apply these commands for scaling? No because there will be our yml file and we can change it when we need scale.

>> Show when you apply mydeployment.yaml change, how differ?

- Delete a pod and show new pod is immediately created.

  
kubectl delete pod <pod-name>
kubectl get pods
   

- Delete deployments

  
kubectl delete deploy <deployment-name>
   

## Part 3 - Deployment Rolling Update and Rollback in Kubernetes

- Create a new folder name it deployment-lesson.

  
mkdir deployment-lesson
cd deployment-lesson
   

- Create a `clarus-deploy.yaml` and input text below. Pay attention that image version is 1.0.

   yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: clarus-deploy
  labels:
    app: container-info
  annotations:
    kubernetes.io/change-cause: deploy/clarus-deploy is set as container-info=clarusway/container-info:1.0
spec:
  replicas: 3
  selector:
    matchLabels:
      app: container-info
  template:
    metadata:
      labels:
        app: container-info
    spec:
      containers:
      - name: container-info
        image: clarusway/container-info:1.0
        ports:
        - containerPort: 80
   

- Create the deployment with `kubectl apply` command.

  
kubectl apply -f clarus-deploy.yaml
   

- List the `Deployment`, `ReplicaSet` and `Pods` of `clarus-deploy` deployment using a label and note the name of ReplicaSet.

  
kubectl get deploy,rs,po -l app=container-info
   

- Describe deployment and note the image of the deployment. In our case, it is clarusway/container-info:1.0.

  
kubectl describe deploy clarus-deploy
   

- View previous rollout revisions.

  
kubectl rollout history deploy clarus-deploy
   

- Display details with revision number, in our case, is 1. And note name of image.

  
kubectl rollout history deploy clarus-deploy --revision=1
   

- Upgrade image.

  
kubectl set image deploy clarus-deploy container-info=clarusway/container-info:2.0
   

- Show the rollout history.

  
kubectl rollout history deploy clarus-deploy
   

- Display details about the revisions.

  
kubectl rollout history deploy clarus-deploy --revision=1
kubectl rollout history deploy clarus-deploy --revision=2
   

- List the `Deployment`, `ReplicaSet` and `Pods` of `clarus-deploy` deployment using a label and explain ReplicaSets.

  
kubectl get deploy,rs,po -l app=container-info
   

- Upgrade image with kubectl edit commands.

  
kubectl edit deploy/clarus-deploy
   

- We will see an output like below.

   yaml
# Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: "2"
    kubectl.kubernetes.io/last-applied-configuration: |
    ...
   

- Change the `metadata.annotations.kubernetes.io/change-cause` and `spec.template.spec.containers.image` fields as below.

   yaml
...
...
    kubernetes.io/change-cause: kubectl set image deploy clarus-deploy container-info=clarusway/container-info:3.0
...
...
    spec:
      containers:
      - image: clarusway/container-info:3.0
...
...
   

- Show the rollout history.

  
kubectl rollout history deploy clarus-deploy
   

- Display details about the revisions.

  
kubectl rollout history deploy clarus-deploy --revision=1
kubectl rollout history deploy clarus-deploy --revision=2
kubectl rollout history deploy clarus-deploy --revision=3
   

- Apply `kubectl get rs` and show how many replica set exist and explain why?

- List the `Deployment`, `ReplicaSet` and `Pods` of `clarus-deploy` deployment using a label and explain ReplicaSets.

  
kubectl get deploy,rs,po -l app=container-info
   

- Rollback to `revision 1`.

  
kubectl rollout undo deploy clarus-deploy --to-revision=1
   

- Show the rollout history and show that we have revision 2, 3 and 4. Explain that original revision, which is `revision 1`, becomes `revision 4`.

  
kubectl rollout history deploy clarus-deploy
kubectl rollout history deploy clarus-deploy --revision=2
kubectl rollout history deploy clarus-deploy --revision=2
kubectl rollout history deploy clarus-deploy --revision=4
   

- Try to pull up the `revision 1`, that is no longer available.

  
kubectl rollout history deploy clarus-deploy --revision=1
   

- List the `Deployment`, `ReplicaSet` and `Pods` of `mynginx` deployment using a label, and explain that the original ReplicaSet has been scaled up back to three and second ReplicaSet has been scaled down to zero.

  
kubectl get deploy,rs,po -l app=container-info
   

- Delete the deployment.

  
kubectl delete deploy -l app=container-info
   

## Part 4 - Namespaces in Kubernetes

- List the current namespaces in a cluster using and explain them. *Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called `namespaces`.*

  
kubectl get namespace
NAME              STATUS   AGE
default           Active   118m
kube-node-lease   Active   118m
kube-public       Active   118m
kube-system       Active   118m
   

>### default
>The default namespace for objects with no other namespace

>### kube-system
>The namespace for objects created by the Kubernetes system

>### kube-public
>This namespace is created automatically and is readable by all users (including those not authenticated). This >namespace is mostly reserved for cluster usage, in case that some resources should be visible and readable >publicly throughout the whole cluster. The public aspect of this namespace is only a convention, not a >requirement.

>### kube-node-lease
>This namespace for the lease objects associated with each node which improves the performance of the node  heartbeats as the cluster scales.

- Create a new YAML file called `my-namespace.yaml` with the following content.

   yaml
apiVersion: v1
kind: Namespace
metadata:
  name: clarus-namespace
   

- Create a namespace using the `my-namespace.yaml` file.

  
kubectl apply -f ./my-namespace.yaml
   

- Alternatively, you can create namespace using below command:

  
kubectl create namespace <namespace-name>
   

- Create pods in each namespace.

  
kubectl create deployment default-ns --image=nginx
kubectl create deployment clarus-ns --image=nginx -n=clarus-namespace
   

- List the deployments in `default` namespace.

  
kubectl get deployment
   

- List the deployments in `clarus-namespace`.

  
kubectl get deployment -n clarus-namespace
   

- List the all deployments.

  
kubectl get deployment -o wide --all-namespaces
   

- Delete the namespace.

  
kubectl delete namespaces clarus-namespace
   